{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"","text":"<p>The main goal of SocketAPI is to provide an easy-to-use and flexible framework for building WebSocket APIs using Python. It leverages the power of Starlette for handling WebSocket connections and Pydantic for data validation and serialization. It uses a single multiplexed WebSocket connection, allowing clients to exchange different types of information through endpoint-like actions and channel subscriptions, defined similarly to routes in FastAPI. The framework is inspired by both FastAPI and Phoenix LiveView, combining familiar declarative endpoints with real-time, channel-oriented communication.</p>"},{"location":"#installation","title":"Installation","text":"<p>You can install SocketAPI using pip:</p> <pre><code>pip install socketapi\n</code></pre>"},{"location":"#simple-example","title":"Simple example","text":""},{"location":"#server","title":"Server","text":"<pre><code>from socketapi import SocketAPI\n\napp = SocketAPI()\n\n# Define \"add_numbers\" action - endpoint for performing calculations\n@app.action(\"add_numbers\")\nasync def add_numbers(a: int, b: int) -&gt; int:\n    return a + b\n\n# Define \"chat\" channel - subscription for receiving messages\n@app.channel(\"chat\")\nasync def chat_channel(message: str = \"Welcome\"):\n    return {\"message\": message}\n\n# Action that sends a message to all \"chat\" channel subscribers\n@app.action(\"send_message\")\nasync def send_message(message: str):\n    await chat_channel(message=message)\n</code></pre> <p>Run the server with any ASGI server (e.g., Uvicorn): <pre><code>uvicorn main:app --reload\n</code></pre></p>"},{"location":"#client-usage","title":"Client Usage","text":"<p>Connect to the WebSocket endpoint at <code>ws://localhost:8000/</code> and exchange JSON messages.</p>"},{"location":"#calling-an-action-request-response-pattern","title":"Calling an action (request-response pattern)","text":"<p>Send: <pre><code>{\"type\": \"action\", \"channel\": \"add_numbers\", \"data\": {\"a\": 5, \"b\": 3}}\n</code></pre></p> <p>Receive: <pre><code>{\"type\": \"action\", \"channel\": \"add_numbers\", \"status\": \"completed\", \"data\": 8}\n</code></pre></p>"},{"location":"#subscribing-to-a-channel-pubsub-pattern","title":"Subscribing to a channel (pub/sub pattern)","text":"<p>Send: <pre><code>{\"type\": \"subscribe\", \"channel\": \"chat\"}\n</code></pre></p> <p>Receive confirmation: <pre><code>{\"type\": \"subscribed\", \"channel\": \"chat\"}\n</code></pre></p>"},{"location":"#broadcasting-to-channel-subscribers","title":"Broadcasting to channel subscribers","text":"<p>Send: <pre><code>{\"type\": \"action\", \"channel\": \"send_message\", \"data\": {\"message\": \"Hello everyone!\"}}\n</code></pre></p> <p>Receive confirmation: <pre><code>{\"type\": \"action\", \"channel\": \"send_message\", \"status\": \"completed\"}\n</code></pre></p> <p>All subscribers receive: <pre><code>{\"type\": \"data\", \"channel\": \"chat\", \"data\": {\"message\": \"Hello everyone!\"}}\n</code></pre></p> <p>How it works:</p> <ul> <li>Actions (<code>@app.action</code>) - endpoint-like, request-response pattern. Client sends a request and receives a response.</li> <li>Channels (<code>@app.channel</code>) - pub/sub pattern. Client subscribes to a channel and automatically receives all data emitted to that channel.</li> <li>Single WebSocket - all operations (actions, channels) work through a single WebSocket connection multiplexed via the <code>channel</code> field.</li> </ul>"},{"location":"Development/changelog/","title":"Changelog","text":"<p>Changes for each release are thoroughly documented in release notes</p>"},{"location":"Development/contributing/","title":"Contributing","text":"<p>Contributions are welcome! Feel free to open an issue or submit a pull request. I would like to keep the library to be safe as possible, so i would appreciate if you cover any new feature with tests to maintain 100% coverage.</p>"},{"location":"Development/contributing/#install-in-a-development-environment","title":"Install in a development environment","text":"<ol> <li> <p>First, clone the repository:</p> <pre><code>git clone git@github.com:SpaceShaman/socketapi.git\n</code></pre> </li> <li> <p>Install uv if you don't have it:</p> <pre><code>curl -LsSf https://astral.sh/uv/install.sh | sh\n</code></pre> </li> <li> <p>Create a virtual environment and install the dependencies:</p> <pre><code>cd socketapi\nuv sync\n</code></pre> </li> </ol>"},{"location":"Development/contributing/#run-tests","title":"Run tests","text":"<p>You can run the tests with the following command:</p> <pre><code>uv run pytest\n</code></pre> <p>You can also run the tests with coverage: <pre><code>uv run pytest --cov=socketapi\n</code></pre></p>"},{"location":"Development/license/","title":"License","text":"<p>MIT License</p> <p>Copyright (c) 2025 SpaceShaman</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"Development/roadmap/","title":"Features and Roadmap","text":"<ul> <li> Define actions with request-response pattern</li> <li> Define channels with pub/sub pattern</li> <li> Single multiplexed WebSocket connection</li> <li> Pydantic models for data validation</li> <li> Error handling and validation</li> <li> Dependency injection system (like FastAPI)</li> <li> Router class for splitting API into multiple files similar to FastAPI</li> <li> Broadcasting messages from outside the server context by calling channel-decorated functions</li> <li> Error reporting inside decorated handlers with automatic error messages sent to client</li> <li> Dynamic channel paths with parameter extraction (e.g., chat/{room_id}) with automatic mapping to channel handler arguments</li> <li> JavaScript/TypeScript client library for easier integration with web applications</li> </ul>"},{"location":"Usage/actions/","title":"Actions","text":"<p>Actions in SocketAPI implement a request-response pattern similar to REST API endpoints. When you decorate a function with <code>@app.action()</code>, it becomes an endpoint that clients can call and receive a response.</p>"},{"location":"Usage/actions/#basic-action-definition","title":"Basic Action Definition","text":"<pre><code>from socketapi import SocketAPI\n\napp = SocketAPI()\n\n@app.action(\"greet\")\nasync def greet(name: str):\n    return {\"message\": f\"Hello, {name}!\"}\n</code></pre> <p>This creates an action named <code>\"greet\"</code> that clients can invoke.</p>"},{"location":"Usage/actions/#calling-an-action","title":"Calling an Action","text":"<p>Clients call an action by sending a message with <code>type: \"action\"</code>:</p> <p>Send: <pre><code>{\n    \"type\": \"action\",\n    \"channel\": \"greet\",\n    \"data\": {\"name\": \"Alice\"}\n}\n</code></pre></p> <p>Receive: <pre><code>{\n    \"type\": \"action\",\n    \"channel\": \"greet\",\n    \"status\": \"completed\",\n    \"data\": {\"message\": \"Hello, Alice!\"}\n}\n</code></pre></p>"},{"location":"Usage/actions/#actions-without-parameters","title":"Actions Without Parameters","text":"<p>You can define actions that don't require any parameters:</p> <pre><code>@app.action(\"ping\")\nasync def ping():\n    return {\"status\": \"ok\"}\n</code></pre> <p>Send: <pre><code>{\"type\": \"action\", \"channel\": \"ping\"}\n</code></pre></p> <p>Receive: <pre><code>{\n    \"type\": \"action\",\n    \"channel\": \"ping\",\n    \"status\": \"completed\",\n    \"data\": {\"status\": \"ok\"}\n}\n</code></pre></p>"},{"location":"Usage/actions/#actions-without-return-value","title":"Actions Without Return Value","text":"<p>Actions can perform operations without returning data:</p> <pre><code>@app.action(\"log_event\")\nasync def log_event(event: str):\n    print(f\"Event logged: {event}\")\n    # No return statement\n</code></pre> <p>Send: <pre><code>{\n    \"type\": \"action\",\n    \"channel\": \"log_event\",\n    \"data\": {\"event\": \"user_login\"}\n}\n</code></pre></p> <p>Receive (no <code>data</code> field): <pre><code>{\n    \"type\": \"action\",\n    \"channel\": \"log_event\",\n    \"status\": \"completed\"\n}\n</code></pre></p>"},{"location":"Usage/actions/#multiple-parameters","title":"Multiple Parameters","text":"<p>Actions support multiple typed parameters:</p> <pre><code>@app.action(\"calculate\")\nasync def calculate(a: int, b: int, operation: str):\n    if operation == \"add\":\n        result = a + b\n    elif operation == \"multiply\":\n        result = a * b\n    else:\n        result = 0\n    return {\"result\": result}\n</code></pre> <p>Send: <pre><code>{\n    \"type\": \"action\",\n    \"channel\": \"calculate\",\n    \"data\": {\"a\": 5, \"b\": 3, \"operation\": \"add\"}\n}\n</code></pre></p> <p>Receive: <pre><code>{\n    \"type\": \"action\",\n    \"channel\": \"calculate\",\n    \"status\": \"completed\",\n    \"data\": {\"result\": 8}\n}\n</code></pre></p>"},{"location":"Usage/actions/#data-validation","title":"Data Validation","text":"<p>SocketAPI uses Pydantic for automatic parameter validation. If parameters are missing or have incorrect types, an error is returned:</p> <p>Missing parameter:</p> <p>Send: <pre><code>{\n    \"type\": \"action\",\n    \"channel\": \"calculate\",\n    \"data\": {\"a\": 5, \"b\": 3}\n}\n</code></pre></p> <p>Receive: <pre><code>{\n    \"type\": \"error\",\n    \"message\": \"Invalid parameters for action 'calculate'\"\n}\n</code></pre></p> <p>Incorrect type:</p> <p>Send: <pre><code>{\n    \"type\": \"action\",\n    \"channel\": \"calculate\",\n    \"data\": {\"a\": \"not_a_number\", \"b\": 3, \"operation\": \"add\"}\n}\n</code></pre></p> <p>Receive: <pre><code>{\n    \"type\": \"error\",\n    \"message\": \"Invalid parameters for action 'calculate'\"\n}\n</code></pre></p> <p>Note: Pydantic performs type coercion when possible. For example, <code>\"5\"</code> (string) can be converted to <code>5</code> (int).</p>"},{"location":"Usage/actions/#using-pydantic-models","title":"Using Pydantic Models","text":"<p>For complex data structures, you can use Pydantic models:</p> <pre><code>from pydantic import BaseModel\n\nclass UserData(BaseModel):\n    username: str\n    email: str\n    age: int\n\nclass UserResponse(BaseModel):\n    id: int\n    username: str\n    created: bool\n\n@app.action(\"create_user\")\nasync def create_user(user: UserData) -&gt; UserResponse:\n    # Create user in database\n    return UserResponse(id=1, username=user.username, created=True)\n</code></pre> <p>Send: <pre><code>{\n    \"type\": \"action\",\n    \"channel\": \"create_user\",\n    \"data\": {\n        \"user\": {\n            \"username\": \"alice\",\n            \"email\": \"alice@example.com\",\n            \"age\": 25\n        }\n    }\n}\n</code></pre></p> <p>Receive: <pre><code>{\n    \"type\": \"action\",\n    \"channel\": \"create_user\",\n    \"status\": \"completed\",\n    \"data\": {\n        \"id\": 1,\n        \"username\": \"alice\",\n        \"created\": true\n    }\n}\n</code></pre></p>"},{"location":"Usage/actions/#nested-pydantic-models","title":"Nested Pydantic Models","text":"<p>You can use nested models for more complex structures:</p> <pre><code>from pydantic import BaseModel\n\nclass Address(BaseModel):\n    street: str\n    city: str\n    zipcode: str\n\nclass UserProfile(BaseModel):\n    name: str\n    email: str\n    address: Address\n\n@app.action(\"update_profile\")\nasync def update_profile(profile: UserProfile):\n    # Update user profile\n    return {\"success\": True, \"name\": profile.name}\n</code></pre> <p>Send: <pre><code>{\n    \"type\": \"action\",\n    \"channel\": \"update_profile\",\n    \"data\": {\n        \"profile\": {\n            \"name\": \"Alice\",\n            \"email\": \"alice@example.com\",\n            \"address\": {\n                \"street\": \"123 Main St\",\n                \"city\": \"Springfield\",\n                \"zipcode\": \"12345\"\n            }\n        }\n    }\n}\n</code></pre></p>"},{"location":"Usage/actions/#returning-pydantic-models","title":"Returning Pydantic Models","text":"<p>When you return a Pydantic model, it's automatically serialized to JSON:</p> <pre><code>class Product(BaseModel):\n    id: int\n    name: str\n    price: float\n\n@app.action(\"get_product\")\nasync def get_product(product_id: int) -&gt; Product:\n    return Product(id=product_id, name=\"Widget\", price=9.99)\n</code></pre> <p>Receive: <pre><code>{\n    \"type\": \"action\",\n    \"channel\": \"get_product\",\n    \"status\": \"completed\",\n    \"data\": {\n        \"id\": 1,\n        \"name\": \"Widget\",\n        \"price\": 9.99\n    }\n}\n</code></pre></p>"},{"location":"Usage/actions/#combining-actions-with-channels","title":"Combining Actions with Channels","text":"<p>Actions are commonly used to broadcast data to channels:</p> <pre><code>@app.channel(\"chat\")\nasync def chat_channel(message: str):\n    return {\"message\": message}\n\n@app.action(\"send_message\")\nasync def send_message(text: str, user: str):\n    # Broadcast to all chat subscribers\n    await chat_channel(message=f\"{user}: {text}\")\n    return {\"sent\": True}\n</code></pre> <p>When a client calls the action:</p> <p>Send: <pre><code>{\n    \"type\": \"action\",\n    \"channel\": \"send_message\",\n    \"data\": {\"text\": \"Hello everyone!\", \"user\": \"Alice\"}\n}\n</code></pre></p> <p>The calling client receives: <pre><code>{\n    \"type\": \"action\",\n    \"channel\": \"send_message\",\n    \"status\": \"completed\",\n    \"data\": {\"sent\": true}\n}\n</code></pre></p> <p>All subscribers to the \"chat\" channel receive: <pre><code>{\n    \"type\": \"data\",\n    \"channel\": \"chat\",\n    \"data\": {\"message\": \"Alice: Hello everyone!\"}\n}\n</code></pre></p>"},{"location":"Usage/actions/#error-handling","title":"Error Handling","text":"<p>If a client tries to call a non-existent action:</p> <p>Send: <pre><code>{\"type\": \"action\", \"channel\": \"nonexistent_action\"}\n</code></pre></p> <p>Receive: <pre><code>{\n    \"type\": \"error\",\n    \"message\": \"Action 'nonexistent_action' not found.\"\n}\n</code></pre></p>"},{"location":"Usage/actions/#complete-example","title":"Complete Example","text":"<pre><code>from pydantic import BaseModel\nfrom socketapi import SocketAPI\n\napp = SocketAPI()\n\nclass Message(BaseModel):\n    user: str\n    text: str\n\nclass MessageResponse(BaseModel):\n    id: int\n    timestamp: int\n    sent: bool\n\n@app.channel(\"chat_room\")\nasync def chat_room(message: Message):\n    return message\n\n@app.action(\"post_message\")\nasync def post_message(message: Message) -&gt; MessageResponse:\n    # Save message to database\n    import time\n    message_id = 1\n    timestamp = int(time.time())\n\n    # Broadcast to all chat room subscribers\n    await chat_room(message=message)\n\n    # Return confirmation to sender\n    return MessageResponse(id=message_id, timestamp=timestamp, sent=True)\n\n@app.action(\"get_history\")\nasync def get_history(limit: int = 10) -&gt; dict[str, list]:\n    # Fetch chat history from database\n    return {\"messages\": []}\n</code></pre> <p>Client workflow:</p> <ol> <li> <p>Call action to post a message: <pre><code>{\n    \"type\": \"action\",\n    \"channel\": \"post_message\",\n    \"data\": {\n        \"message\": {\n            \"user\": \"Alice\",\n            \"text\": \"Hello!\"\n        }\n    }\n}\n</code></pre></p> </li> <li> <p>Receive confirmation: <pre><code>{\n    \"type\": \"action\",\n    \"channel\": \"post_message\",\n    \"status\": \"completed\",\n    \"data\": {\n        \"id\": 1,\n        \"timestamp\": 1701234567,\n        \"sent\": true\n    }\n}\n</code></pre></p> </li> <li> <p>All subscribers to \"chat_room\" receive: <pre><code>{\n    \"type\": \"data\",\n    \"channel\": \"chat_room\",\n    \"data\": {\n        \"user\": \"Alice\",\n        \"text\": \"Hello!\"\n    }\n}\n</code></pre></p> </li> <li> <p>Get chat history: <pre><code>{\n    \"type\": \"action\",\n    \"channel\": \"get_history\",\n    \"data\": {\"limit\": 20}\n}\n</code></pre></p> </li> </ol>"},{"location":"Usage/channels/","title":"Channels","text":"<p>Channels in SocketAPI implement a publish/subscribe pattern, allowing clients to subscribe to real-time data streams. When you decorate a function with <code>@app.channel()</code>, it becomes a broadcasting endpoint that can push data to all subscribed clients.</p>"},{"location":"Usage/channels/#basic-channel-definition","title":"Basic Channel Definition","text":"<pre><code>from socketapi import SocketAPI\n\napp = SocketAPI()\n\n@app.channel(\"chat\")\nasync def chat_channel(message: str = \"Welcome\"):\n    return {\"message\": message}\n</code></pre> <p>This creates a channel named <code>\"chat\"</code> that clients can subscribe to.</p>"},{"location":"Usage/channels/#subscribing-to-a-channel","title":"Subscribing to a Channel","text":"<p>Clients subscribe by sending a message with <code>type: \"subscribe\"</code>:</p> <p>Send: <pre><code>{\"type\": \"subscribe\", \"channel\": \"chat\"}\n</code></pre></p> <p>Receive confirmation: <pre><code>{\"type\": \"subscribed\", \"channel\": \"chat\"}\n</code></pre></p> <p>By default, clients do not receive initial data automatically after subscribing. They only receive the confirmation message. To enable automatic initial data delivery, use <code>default_response=True</code>.</p>"},{"location":"Usage/channels/#unsubscribing-from-a-channel","title":"Unsubscribing from a Channel","text":"<p>Clients can unsubscribe at any time:</p> <p>Send: <pre><code>{\"type\": \"unsubscribe\", \"channel\": \"chat\"}\n</code></pre></p> <p>Receive: <pre><code>{\"type\": \"unsubscribed\", \"channel\": \"chat\"}\n</code></pre></p> <p>When a WebSocket connection closes, clients are automatically unsubscribed from all channels.</p>"},{"location":"Usage/channels/#broadcasting-messages","title":"Broadcasting Messages","text":"<p>Once a channel is defined, you can broadcast messages to all subscribers by calling the decorated function:</p> <pre><code>@app.channel(\"chat\")\nasync def chat_channel(message: str):\n    return {\"message\": message}\n\n@app.action(\"send_message\")\nasync def send_message(text: str):\n    # Broadcast to all subscribers of the \"chat\" channel\n    await chat_channel(message=text)\n</code></pre> <p>All subscribers will receive: <pre><code>{\"type\": \"data\", \"channel\": \"chat\", \"data\": {\"message\": \"text from action\"}}\n</code></pre></p>"},{"location":"Usage/channels/#default-response-behavior","title":"Default Response Behavior","text":"<p>By default, channels do not send initial data immediately after a client subscribes. You can enable this behavior by setting <code>default_response=True</code>:</p> <pre><code>@app.channel(\"news\", default_response=True)\nasync def news_channel():\n    return {\"headline\": \"Breaking News!\"}\n</code></pre> <p>Send: <pre><code>{\"type\": \"subscribe\", \"channel\": \"news\"}\n</code></pre></p> <p>Receive confirmation and initial data: <pre><code>{\"type\": \"subscribed\", \"channel\": \"news\"}\n{\"type\": \"data\", \"channel\": \"news\", \"data\": {\"headline\": \"Breaking News!\"}}\n</code></pre></p>"},{"location":"Usage/channels/#parameters-and-validation","title":"Parameters and Validation","text":"<p>Channels support typed parameters with automatic validation using Pydantic:</p> <pre><code>@app.channel(\"user_updates\")\nasync def user_updates(user_id: int, include_details: bool = True):\n    # Fetch user data based on parameters\n    return {\"user_id\": user_id, \"details\": include_details}\n</code></pre> <p>When broadcasting, pass parameters as keyword arguments:</p> <pre><code>await user_updates(user_id=123, include_details=False)\n</code></pre>"},{"location":"Usage/channels/#required-parameters-on-subscribe","title":"Required Parameters on Subscribe","text":"<p>You can require clients to provide parameters when subscribing using the <code>RequiredOnSubscribe</code> annotation:</p> <pre><code>from typing import Annotated\nfrom socketapi import RequiredOnSubscribe, SocketAPI\n\napp = SocketAPI()\n\n@app.channel(\"private_chat\")\nasync def private_chat(\n    token: Annotated[str, RequiredOnSubscribe],\n    message: str = \"Welcome\"\n):\n    # Validate token, fetch user data, etc.\n    return {\"message\": message, \"authenticated\": True}\n</code></pre> <p>Clients must provide required parameters when subscribing:</p> <p>Send: <pre><code>{\n    \"type\": \"subscribe\",\n    \"channel\": \"private_chat\",\n    \"data\": {\"token\": \"secret_token\"}\n}\n</code></pre></p> <p>Receive: <pre><code>{\"type\": \"subscribed\", \"channel\": \"private_chat\"}\n</code></pre></p> <p>Note: By default, no initial data is sent automatically. To receive initial data after subscribing, set <code>default_response=True</code> on the channel decorator.</p> <p>If required parameters are missing or invalid:</p> <p>Send: <pre><code>{\"type\": \"subscribe\", \"channel\": \"private_chat\"}\n</code></pre></p> <p>Receive error: <pre><code>{\n    \"type\": \"error\",\n    \"message\": \"Invalid parameters for action 'private_chat'\"\n}\n</code></pre></p>"},{"location":"Usage/channels/#using-pydantic-models","title":"Using Pydantic Models","text":"<p>You can use Pydantic models for complex data structures:</p> <pre><code>from pydantic import BaseModel\n\nclass ChatMessage(BaseModel):\n    user: str\n    text: str\n    timestamp: int\n\n@app.channel(\"typed_chat\")\nasync def typed_chat(message: ChatMessage = ChatMessage(user=\"system\", text=\"Welcome\", timestamp=0)):\n    return message\n</code></pre>"},{"location":"Usage/channels/#error-handling","title":"Error Handling","text":"<p>If a client tries to subscribe to a non-existent channel:</p> <p>Send: <pre><code>{\"type\": \"subscribe\", \"channel\": \"nonexistent\"}\n</code></pre></p> <p>Receive: <pre><code>{\n    \"type\": \"error\",\n    \"message\": \"Channel 'nonexistent' not found.\"\n}\n</code></pre></p>"},{"location":"Usage/channels/#broadcasting-from-outside-server-context","title":"Broadcasting from Outside Server Context","text":"<p>One of the most powerful features of SocketAPI channels is the ability to call channel functions from outside the server context - even from different processes or threads. This makes it incredibly useful for integrating with other technologies that run in separate processes.</p>"},{"location":"Usage/channels/#use-cases","title":"Use Cases","text":"<ul> <li>Background tasks: Celery workers, RQ jobs, or other task queues</li> <li>Database triggers: PostgreSQL NOTIFY/LISTEN or other database events</li> <li>External services: Webhooks, message queues (RabbitMQ, Redis), or third-party APIs</li> <li>Scheduled jobs: Cron jobs or APScheduler tasks</li> <li>Separate processes: Any Python process that has access to your SocketAPI app instance</li> </ul>"},{"location":"Usage/channels/#how-it-works","title":"How It Works","text":"<p>Channel functions work seamlessly regardless of where they're called from. When called from outside the WebSocket request context, SocketAPI automatically handles broadcasting to all subscribed clients.</p> <pre><code>from socketapi import SocketAPI\n\napp = SocketAPI()\n\n@app.channel(\"broadcast_channel\")\nasync def broadcast_channel(message: str):\n    return {\"message\": message}\n\n# This works from anywhere - inside actions, background tasks, or external processes\nasync def external_process():\n    # Call from a completely different context\n    await broadcast_channel(message=\"Hello from external process!\")\n</code></pre>"},{"location":"Usage/channels/#custom-host-and-port-configuration","title":"Custom Host and Port Configuration","text":"<p>If the server is running on a different host than <code>localhost</code> or a different port than <code>8000</code>, you need to provide these details when creating the SocketAPI object so that other processes know the server address and can communicate with it:</p> <pre><code>from socketapi import SocketAPI\n\n# Server running on custom host and/or port\napp = SocketAPI(host=\"192.168.1.100\", port=9000)\n\n# Now external processes can broadcast to this server\n</code></pre> <p>If the server is running on the default host (<code>localhost</code>) and port (<code>8000</code>), no additional configuration is needed.</p>"},{"location":"Usage/channels/#important-notes","title":"Important Notes","text":"<ul> <li>Channel functions are thread-safe and process-safe</li> <li>No special configuration needed - it just works!</li> <li>All subscribed clients receive broadcasts regardless of where the function is called</li> <li>Parameters are validated the same way as when called from actions</li> </ul> <p>Broadcasting from a Different Machine</p> <p>By default, the broadcast endpoint only accepts connections from localhost (<code>127.0.0.1</code>, <code>::1</code>, <code>localhost</code>) for security reasons. If you need to call channel functions from a different machine or server, you must explicitly configure <code>broadcast_allowed_hosts</code> when creating the SocketAPI instance:</p> <pre><code>app = SocketAPI(\n    host=\"0.0.0.0\",\n    port=8000,\n    broadcast_allowed_hosts=(\"127.0.0.1\", \"::1\", \"localhost\", \"192.168.1.50\")\n)\n</code></pre> <p>Add the IP address of the machine that needs to communicate with the server to the <code>broadcast_allowed_hosts</code> tuple.</p> <p>This feature makes SocketAPI perfect for building real-time applications that need to integrate with existing infrastructure and external services.</p>"},{"location":"Usage/channels/#complete-example","title":"Complete Example","text":"<pre><code>from typing import Annotated\nfrom socketapi import RequiredOnSubscribe, SocketAPI\n\napp = SocketAPI()\n\n@app.channel(\"notifications\")\nasync def notifications(user_id: Annotated[int, RequiredOnSubscribe], notification_type: str = \"all\"):\n    # Fetch notifications for the user\n    return {\n        \"user_id\": user_id,\n        \"type\": notification_type,\n        \"notifications\": []\n    }\n\n@app.action(\"send_notification\")\nasync def send_notification(user_id: int, message: str):\n    # Broadcast notification to specific user's subscribers\n    await notifications(user_id=user_id, notification_type=\"alert\")\n</code></pre> <p>Client workflow:</p> <ol> <li> <p>Subscribe with required parameters: <pre><code>{\"type\": \"subscribe\", \"channel\": \"notifications\", \"data\": {\"user_id\": 123}}\n</code></pre></p> </li> <li> <p>Receive confirmation (no initial data by default): <pre><code>{\"type\": \"subscribed\", \"channel\": \"notifications\"}\n</code></pre></p> </li> <li> <p>Receive broadcasts when <code>send_notification</code> is called: <pre><code>{\"type\": \"data\", \"channel\": \"notifications\", \"data\": {\"user_id\": 123, \"type\": \"alert\", \"notifications\": []}}\n</code></pre></p> </li> <li> <p>Unsubscribe when done: <pre><code>{\"type\": \"unsubscribe\", \"channel\": \"notifications\"}\n</code></pre></p> </li> </ol>"},{"location":"Usage/dependencies/","title":"Dependencies","text":"<p>Dependencies in SocketAPI allow you to inject reusable logic into your actions and channels. Using the <code>Depends</code> function with Python's <code>Annotated</code> type hints, you can create shared functionality like authentication, database connections, or data processing that can be reused across multiple endpoints.</p>"},{"location":"Usage/dependencies/#basic-dependency-definition","title":"Basic Dependency Definition","text":"<pre><code>from typing import Annotated\nfrom socketapi import Depends, SocketAPI\n\napp = SocketAPI()\n\nasync def common_dependency(a: int, b: str) -&gt; str:\n    return \"dependency result\"\n\n@app.action(\"greet\")\nasync def greet(dep: Annotated[str, Depends(common_dependency)]):\n    return {\"message\": dep}\n</code></pre> <p>This creates a dependency function <code>common_dependency</code> that can be injected into any action or channel.</p>"},{"location":"Usage/dependencies/#using-dependencies-in-actions","title":"Using Dependencies in Actions","text":"<p>When you use a dependency in an action, clients must provide the dependency's parameters within the action call:</p> <p>Send: <pre><code>{\n    \"type\": \"action\",\n    \"channel\": \"greet\",\n    \"data\": {\n        \"dep\": {\n            \"a\": 42,\n            \"b\": \"hello\"\n        }\n    }\n}\n</code></pre></p> <p>Receive: <pre><code>{\n    \"type\": \"action\",\n    \"channel\": \"greet\",\n    \"status\": \"completed\",\n    \"data\": {\"message\": \"dependency result\"}\n}\n</code></pre></p> <p>The dependency function <code>common_dependency</code> receives the parameters <code>a</code> and <code>b</code> from the nested <code>dep</code> object in the request data.</p>"},{"location":"Usage/dependencies/#nested-dependencies","title":"Nested Dependencies","text":"<p>Dependencies can depend on other dependencies, creating a chain of reusable components:</p> <pre><code>async def common_dependency(a: int, b: str) -&gt; str:\n    return \"dependency result\"\n\nasync def nested_dependency(\n    x: Annotated[str, Depends(common_dependency)]\n) -&gt; dict[str, str]:\n    return {\"x\": x}\n\n@app.action(\"process\")\nasync def process(\n    dep: Annotated[dict[str, str], Depends(nested_dependency)]\n) -&gt; dict[str, str]:\n    return dep\n</code></pre> <p>Send: <pre><code>{\n    \"type\": \"action\",\n    \"channel\": \"process\",\n    \"data\": {\n        \"dep\": {\n            \"x\": {\n                \"a\": 100,\n                \"b\": \"world\"\n            }\n        }\n    }\n}\n</code></pre></p> <p>Receive: <pre><code>{\n    \"type\": \"action\",\n    \"channel\": \"process\",\n    \"status\": \"completed\",\n    \"data\": {\"x\": \"dependency result\"}\n}\n</code></pre></p> <p>The <code>nested_dependency</code> function depends on <code>common_dependency</code>, and the <code>process</code> action depends on <code>nested_dependency</code>. Parameters are nested accordingly in the request data.</p>"},{"location":"Usage/dependencies/#using-pydantic-models-in-dependencies","title":"Using Pydantic Models in Dependencies","text":"<p>Dependencies can use Pydantic models for complex data validation:</p> <pre><code>from pydantic import BaseModel\n\nclass Address(BaseModel):\n    street: str\n    city: str\n    zip_code: str\n\nclass ComplexDataModel(BaseModel):\n    name: str\n    value: int\n    address: Address\n\nasync def complex_data_dependency(complex_data: ComplexDataModel) -&gt; ComplexDataModel:\n    complex_data.value += 10\n    return complex_data\n\n@app.action(\"process_data\")\nasync def process_data(\n    dep: Annotated[ComplexDataModel, Depends(complex_data_dependency)]\n) -&gt; ComplexDataModel:\n    return dep\n</code></pre> <p>Send: <pre><code>{\n    \"type\": \"action\",\n    \"channel\": \"process_data\",\n    \"data\": {\n        \"dep\": {\n            \"complex_data\": {\n                \"name\": \"Test\",\n                \"value\": 5,\n                \"address\": {\n                    \"street\": \"123 Main St\",\n                    \"city\": \"Anytown\",\n                    \"zip_code\": \"12345\"\n                }\n            }\n        }\n    }\n}\n</code></pre></p> <p>Receive: <pre><code>{\n    \"type\": \"action\",\n    \"channel\": \"process_data\",\n    \"status\": \"completed\",\n    \"data\": {\n        \"name\": \"Test\",\n        \"value\": 15,\n        \"address\": {\n            \"street\": \"123 Main St\",\n            \"city\": \"Anytown\",\n            \"zip_code\": \"12345\"\n        }\n    }\n}\n</code></pre></p> <p>The dependency modifies the <code>value</code> field (adding 10) before returning it to the action.</p>"},{"location":"Usage/dependencies/#common-use-cases","title":"Common Use Cases","text":""},{"location":"Usage/dependencies/#authentication","title":"Authentication","text":"<pre><code>from typing import Annotated\n\nclass User(BaseModel):\n    id: int\n    username: str\n    role: str\n\nasync def get_current_user(token: str) -&gt; User:\n    # Validate token and fetch user from database\n    if token == \"invalid\":\n        raise ValueError(\"Invalid token\")\n    return User(id=1, username=\"alice\", role=\"admin\")\n\n@app.action(\"get_profile\")\nasync def get_profile(\n    current_user: Annotated[User, Depends(get_current_user)]\n) -&gt; User:\n    return current_user\n</code></pre> <p>Send: <pre><code>{\n    \"type\": \"action\",\n    \"channel\": \"get_profile\",\n    \"data\": {\n        \"current_user\": {\n            \"token\": \"valid_token_here\"\n        }\n    }\n}\n</code></pre></p>"},{"location":"Usage/dependencies/#database-connection","title":"Database Connection","text":"<pre><code>class DatabaseConnection:\n    def __init__(self, db_url: str):\n        self.db_url = db_url\n\n    async def query(self, sql: str):\n        # Execute query\n        return []\n\nasync def get_db(db_url: str = \"postgresql://localhost/mydb\") -&gt; DatabaseConnection:\n    db = DatabaseConnection(db_url)\n    return db\n\n@app.action(\"fetch_users\")\nasync def fetch_users(\n    db: Annotated[DatabaseConnection, Depends(get_db)]\n):\n    users = await db.query(\"SELECT * FROM users\")\n    return {\"users\": users}\n</code></pre>"},{"location":"Usage/dependencies/#data-transformation","title":"Data Transformation","text":"<pre><code>from datetime import datetime\n\nclass TransformedData(BaseModel):\n    data: str\n    timestamp: int\n    processed: bool\n\nasync def transform_data(raw_data: str) -&gt; TransformedData:\n    return TransformedData(\n        data=raw_data.upper(),\n        timestamp=int(datetime.now().timestamp()),\n        processed=True\n    )\n\n@app.action(\"submit_data\")\nasync def submit_data(\n    transformed: Annotated[TransformedData, Depends(transform_data)]\n) -&gt; TransformedData:\n    # Save transformed data\n    return transformed\n</code></pre> <p>Send: <pre><code>{\n    \"type\": \"action\",\n    \"channel\": \"submit_data\",\n    \"data\": {\n        \"transformed\": {\n            \"raw_data\": \"hello world\"\n        }\n    }\n}\n</code></pre></p> <p>Receive: <pre><code>{\n    \"type\": \"action\",\n    \"channel\": \"submit_data\",\n    \"status\": \"completed\",\n    \"data\": {\n        \"data\": \"HELLO WORLD\",\n        \"timestamp\": 1701234567,\n        \"processed\": true\n    }\n}\n</code></pre></p>"},{"location":"Usage/dependencies/#dependencies-in-channels","title":"Dependencies in Channels","text":"<p>Dependencies work the same way in channels as they do in actions:</p> <pre><code>from typing import Annotated\n\nasync def validate_token(token: str) -&gt; dict:\n    # Validate user token\n    return {\"user_id\": 123, \"valid\": True}\n\n@app.channel(\"private_updates\")\nasync def private_updates(\n    auth: Annotated[dict, Depends(validate_token), RequiredOnSubscribe],\n    message: str = \"Welcome\"\n):\n    return {\"message\": message, \"user_id\": auth[\"user_id\"]}\n</code></pre> <p>Subscribe: <pre><code>{\n    \"type\": \"subscribe\",\n    \"channel\": \"private_updates\",\n    \"data\": {\n        \"auth\": {\n            \"token\": \"secret_token\"\n        }\n    }\n}\n</code></pre></p> <p>Receive: <pre><code>{\"type\": \"subscribed\", \"channel\": \"private_updates\"}\n</code></pre></p> <p>Then receive initial data: <pre><code>{\n    \"type\": \"data\",\n    \"channel\": \"private_updates\",\n    \"data\": {\"message\": \"Welcome\", \"user_id\": 123}\n}\n</code></pre></p>"},{"location":"Usage/dependencies/#multiple-dependencies","title":"Multiple Dependencies","text":"<p>Actions and channels can use multiple dependencies:</p> <pre><code>async def get_user(token: str) -&gt; User:\n    return User(id=1, username=\"alice\", role=\"admin\")\n\nasync def get_settings(theme: str = \"dark\") -&gt; dict:\n    return {\"theme\": theme, \"notifications\": True}\n\n@app.action(\"get_dashboard\")\nasync def get_dashboard(\n    user: Annotated[User, Depends(get_user)],\n    settings: Annotated[dict, Depends(get_settings)]\n):\n    return {\n        \"user\": user,\n        \"settings\": settings\n    }\n</code></pre> <p>Send: <pre><code>{\n    \"type\": \"action\",\n    \"channel\": \"get_dashboard\",\n    \"data\": {\n        \"user\": {\n            \"token\": \"valid_token\"\n        },\n        \"settings\": {\n            \"theme\": \"light\"\n        }\n    }\n}\n</code></pre></p>"},{"location":"Usage/routers/","title":"Routers","text":"<p>Routers in SocketAPI allow you to organize your application into logical groups and split your code across multiple files. This is particularly useful for large applications where you want to separate concerns and maintain a clean project structure.</p>"},{"location":"Usage/routers/#basic-router-usage","title":"Basic Router Usage","text":"<p>Create a router and define channels and actions on it:</p> <pre><code>from socketapi import Router, SocketAPI\n\napp = SocketAPI()\nrouter = Router()\n\n@router.channel(\"notifications\")\nasync def notifications(message: str = \"No new notifications\"):\n    return {\"message\": message}\n\n@router.action(\"mark_as_read\")\nasync def mark_as_read(notification_id: int):\n    return {\"id\": notification_id, \"read\": True}\n\n# Include the router in your app\napp.include_router(router)\n</code></pre>"},{"location":"Usage/routers/#organizing-multiple-files","title":"Organizing Multiple Files","text":"<p>For larger applications, split your routers into separate files:</p>"},{"location":"Usage/routers/#project-structure","title":"Project Structure","text":"<pre><code>my_app/\n\u251c\u2500\u2500 main.py\n\u251c\u2500\u2500 routers/\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 users.py\n\u2502   \u251c\u2500\u2500 chat.py\n\u2502   \u2514\u2500\u2500 notifications.py\n</code></pre>"},{"location":"Usage/routers/#routersuserspy","title":"routers/users.py","text":"<pre><code>from socketapi import Router\nfrom pydantic import BaseModel\n\nrouter = Router()\n\nclass User(BaseModel):\n    id: int\n    username: str\n    email: str\n\n@router.channel(\"user_status\")\nasync def user_status(user_id: int, status: str = \"online\"):\n    return {\"user_id\": user_id, \"status\": status}\n\n@router.action(\"get_user\")\nasync def get_user(user_id: int) -&gt; User:\n    # Fetch user from database\n    return User(id=user_id, username=\"john_doe\", email=\"john@example.com\")\n\n@router.action(\"update_status\")\nasync def update_status(user_id: int, status: str):\n    # Update user status in database\n    await user_status(user_id=user_id, status=status)\n    return {\"success\": True}\n</code></pre>"},{"location":"Usage/routers/#routerschatpy","title":"routers/chat.py","text":"<pre><code>from socketapi import Router\nfrom pydantic import BaseModel\nfrom typing import Annotated\nfrom socketapi import RequiredOnSubscribe\n\nrouter = Router()\n\nclass Message(BaseModel):\n    user: str\n    text: str\n    room: str\n\n@router.channel(\"chat_room\")\nasync def chat_room(\n    room_id: Annotated[str, RequiredOnSubscribe],\n    message: Message | None = None\n):\n    if message:\n        return message\n    return {\"room\": room_id, \"text\": \"Welcome to the chat room!\"}\n\n@router.action(\"send_message\")\nasync def send_message(message: Message):\n    # Save message to database\n    await chat_room(room_id=message.room, message=message)\n    return {\"sent\": True}\n\n@router.action(\"get_history\")\nasync def get_history(room_id: str, limit: int = 50):\n    # Fetch chat history from database\n    return {\"room\": room_id, \"messages\": []}\n</code></pre>"},{"location":"Usage/routers/#routersnotificationspy","title":"routers/notifications.py","text":"<pre><code>from socketapi import Router\nfrom typing import Annotated\nfrom socketapi import RequiredOnSubscribe\n\nrouter = Router()\n\n@router.channel(\"notifications\", default_response=False)\nasync def notifications(\n    user_id: Annotated[int, RequiredOnSubscribe],\n    notification_type: str = \"all\"\n):\n    return {\n        \"user_id\": user_id,\n        \"type\": notification_type,\n        \"count\": 0\n    }\n\n@router.action(\"notify_user\")\nasync def notify_user(user_id: int, message: str, notification_type: str = \"info\"):\n    # Send notification to user\n    await notifications(user_id=user_id, notification_type=notification_type)\n    return {\"notified\": True}\n</code></pre>"},{"location":"Usage/routers/#mainpy","title":"main.py","text":"<pre><code>from socketapi import SocketAPI\nfrom routers import users, chat, notifications\n\napp = SocketAPI()\n\n# Include all routers\napp.include_router(users.router)\napp.include_router(chat.router)\napp.include_router(notifications.router)\n\nif __name__ == \"__main__\":\n    import uvicorn\n    uvicorn.run(app, host=\"0.0.0.0\", port=8000)\n</code></pre>"},{"location":"Usage/routers/#cross-router-communication","title":"Cross-Router Communication","text":"<p>Routers can interact with each other. You can call channel functions from different routers:</p>"},{"location":"Usage/routers/#routersanalyticspy","title":"routers/analytics.py","text":"<pre><code>from socketapi import Router\n\nrouter = Router()\n\n@router.channel(\"analytics\")\nasync def analytics(event: str, data: dict):\n    return {\"event\": event, \"data\": data}\n</code></pre>"},{"location":"Usage/routers/#routersorderspy","title":"routers/orders.py","text":"<pre><code>from socketapi import Router\nfrom .analytics import analytics\n\nrouter = Router()\n\n@router.action(\"create_order\")\nasync def create_order(product_id: int, quantity: int):\n    # Create order in database\n    order_id = 12345\n\n    # Track analytics event\n    await analytics(\n        event=\"order_created\",\n        data={\"order_id\": order_id, \"product_id\": product_id, \"quantity\": quantity}\n    )\n\n    return {\"order_id\": order_id, \"status\": \"created\"}\n</code></pre> <p>Routers make no difference from the client's perspective - all channels and actions are available at the root level, regardless of which router they're defined in.</p>"},{"location":"Usage/testing/","title":"Testing","text":"<p>SocketAPI includes a built-in <code>TestClient</code> based on Starlette's test client, making it easy to test your WebSocket actions and channels.</p>"},{"location":"Usage/testing/#basic-usage","title":"Basic Usage","text":"<pre><code>from socketapi import SocketAPI\nfrom socketapi.testclient import TestClient\n\napp = SocketAPI()\n\n@app.action(\"calculate\")\nasync def calculate(a: int, b: int) -&gt; int:\n    return a + b\n\n@app.channel(\"notifications\")\nasync def notifications(message: str):\n    return {\"message\": message}\n\ndef test_action():\n    client = TestClient(app)\n\n    with client.websocket_connect(\"/\") as websocket:\n        # Send action request\n        websocket.send_json({\n            \"type\": \"action\",\n            \"channel\": \"calculate\",\n            \"data\": {\"a\": 5, \"b\": 3}\n        })\n\n        # Receive response\n        response = websocket.receive_json()\n        assert response[\"data\"] == 8\n        assert response[\"status\"] == \"completed\"\n\ndef test_channel():\n    client = TestClient(app)\n\n    with client.websocket_connect(\"/\") as websocket:\n        # Subscribe to channel\n        websocket.send_json({\n            \"type\": \"subscribe\",\n            \"channel\": \"notifications\"\n        })\n\n        # Receive subscription confirmation\n        response = websocket.receive_json()\n        assert response[\"type\"] == \"subscribed\"\n        assert response[\"channel\"] == \"notifications\"\n</code></pre> <p>The <code>TestClient</code> provides a simple way to test your WebSocket endpoints without running a live server.</p>"}]}